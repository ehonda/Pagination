# This workflow automatically creates a release and publishes to nuget.org, if the package version does not already
# exist. For now it is just copied from this work in progress (which has more context in comments):
#   https://github.com/ehonda/EHonda.HelloNuget/blob/eb9bd36a907fb7ca57b6a88df6e935a285517ca4/.github/workflows/auto-release.yml
#
# This GitHub Actions workflow, named "Release and publish to nuget.org", is triggered on pushes to the `main` branch.
# It orchestrates a series of jobs for multiple projects within the `src` directory to:
#   1. Run tests using a reusable workflow.
#   2. Dynamically determine the list of projects to process using the `define-projects-matrix` job.
#   3. For each project identified by the matrix (handled by a single matrix job "release-and-publish"):
#      a. Extract package metadata (version and ID).
#      b. Check if the extracted package version already exists on nuget.org.
#      c. If the package version does not exist:
#         i. Create a new GitHub release for that package.
#         ii. Pack the project.
#         iii. Publish the new version to nuget.org.
#
# It originates from this:
#   https://github.com/ehonda/EHonda.HelloNuget/blob/eb9bd36a907fb7ca57b6a88df6e935a285517ca4/.github/workflows/auto-release.yml
#
name: Release and publish to nuget.org

# ➡️ Currently disabled, we first have to set up the `NUGET_ORG_API_KEY` secret in the repository settings.
# `workflow_dispatch` is just a placeholder, because `on` is required.
on:
  workflow_dispatch:
#   push:
#     branches:
#       - main

jobs:
  # This job, "test", executes the project's tests.
  # It achieves this by calling the reusable workflow defined in `./.github/workflows/dotnet-test.yml`.
  # This step is crucial for ensuring code quality and correctness before any release or publishing actions are taken.
  test:
    uses: ./.github/workflows/dotnet-test.yml

  # This job, "define-projects-matrix", dynamically determines the list of projects to be processed.
  # It scans the src/ directory for subdirectories containing correspondingly named .csproj files.
  # The output is a JSON array of project names, used by the 'release-and-publish' job's matrix strategy.
  define-projects-matrix:
    name: Define Projects Matrix
    runs-on: ubuntu-latest
    outputs:
      projects: ${{ steps.generate-matrix.outputs.projects }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Generate projects matrix
        id: generate-matrix
        run: |
          PROJECT_LIST=""
          # Iterate over subdirectories in src/
          for dir_path in src/*/; do
            # Remove trailing slash for basename
            dir_path_cleaned=${dir_path%/}
            dir_name=$(basename "$dir_path_cleaned")
            
            # Check if a .csproj file exists in this directory with the same name as the directory
            # e.g., src/Core/Core.csproj
            if [ -f "$dir_path_cleaned/$dir_name.csproj" ]; then
              if [ -z "$PROJECT_LIST" ]; then
                PROJECT_LIST="\\"$dir_name\\""
              else
                PROJECT_LIST="$PROJECT_LIST,\\"$dir_name\\""
              fi
            fi
          done

          JSON_OUTPUT="[$PROJECT_LIST]"
          echo "Generated project matrix: $JSON_OUTPUT" # For debugging
          echo "projects=$JSON_OUTPUT" >> "$GITHUB_OUTPUT"

          # Fail if no projects are found, as this likely indicates an issue.
          if [ -z "$PROJECT_LIST" ]; then
            echo "::error::No projects found matching the pattern src/*/<project_name>.csproj where project name matches directory name."
            echo "Resulting JSON_OUTPUT would be []."
            exit 1
          fi
  # This job, "release-and-publish", handles the entire release and publish process for each project.
  # It uses a matrix strategy to iterate over specified projects. For each project, it:
  # 1. Checks out code and sets up .NET.
  # 2. Extracts package metadata (version and ID).
  # 3. Checks if the package version already exists on NuGet.org.
  # 4. If the version is new, it creates a GitHub release, packs the project, and publishes it to NuGet.org.
  release-and-publish:
    name: Release & Publish ${{ matrix.project_name }}
    runs-on: ubuntu-latest
    needs: [test, define-projects-matrix]
    permissions:
      contents: write # Required for creating GitHub releases
    strategy:
      matrix:
        # Dynamically set project_name from the output of define-projects-matrix job
        project_name: ${{ fromJSON(needs.define-projects-matrix.outputs.projects) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9 # Consider making this configurable if needed

      - name: Get package metadata for ${{ matrix.project_name }}
        id: get-metadata
        run: |
          PROJECT_FILE_PATH="src/${{ matrix.project_name }}/${{ matrix.project_name }}.csproj"
          echo "Attempting to get PackageVersion from $PROJECT_FILE_PATH"
          VERSION_RAW=$(dotnet build "$PROJECT_FILE_PATH" --getProperty:PackageVersion --nologo -v q)
          echo "Attempting to get PackageId from $PROJECT_FILE_PATH"
          ID_RAW=$(dotnet build "$PROJECT_FILE_PATH" --getProperty:PackageId --nologo -v q)

          echo "Raw output for Version for ${{ matrix.project_name }}: [$VERSION_RAW]"
          echo "Raw output for ID for ${{ matrix.project_name }}: [$ID_RAW]"

          VERSION_VAL=$(echo "$VERSION_RAW" | xargs)
          ID_VAL=$(echo "$ID_RAW" | xargs)
          
          echo "Trimmed Version for ${{ matrix.project_name }}: [$VERSION_VAL]"
          echo "Trimmed ID for ${{ matrix.project_name }}: [$ID_VAL]"
          
          if [ -z "$VERSION_VAL" ]; then
            echo "::error::PackageVersion is empty or only whitespace for $PROJECT_FILE_PATH. Raw: [$VERSION_RAW]"
            exit 1
          fi
          if [ -z "$ID_VAL" ]; then
            echo "::error::PackageId is empty or only whitespace for $PROJECT_FILE_PATH. Raw: [$ID_RAW]"
            exit 1
          fi
          
          echo "package-version=$VERSION_VAL" >> "$GITHUB_OUTPUT"
          echo "package-id=$ID_VAL" >> "$GITHUB_OUTPUT"

      - name: Check nuget.org package exists for ${{ matrix.project_name }}
        id: check-nuget
        env:
          PACKAGE_VERSION: ${{ steps.get-metadata.outputs.package-version }}
          PACKAGE_ID: ${{ steps.get-metadata.outputs.package-id }}
        run: |
          PKG_ID_LOWER=$(echo "$PACKAGE_ID" | tr '[:upper:]' '[:lower:]')
          PKG_VERSION_LOWER=$(echo "$PACKAGE_VERSION" | tr '[:upper:]' '[:lower:]')
          NUGET_URL="https://api.nuget.org/v3/registration5-semver1/$PKG_ID_LOWER/$PKG_VERSION_LOWER.json"
          
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$NUGET_URL")
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo -e "\e[32mINFO:\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION already exists on NuGet.org."
            echo "should-release=false" >> $GITHUB_OUTPUT
          elif [ "$HTTP_STATUS" -eq 404 ]; then
            echo -e "\e[32mINFO:\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION does not exist on NuGet.org."
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            echo -e "\e[31mERROR:\e[0m Failed to check NuGet.org for package $PACKAGE_ID@$PACKAGE_VERSION. HTTP Status: $HTTP_STATUS"
            # Fallback logic (optional, consider if nuget CLI is reliably available)
            LATEST_PACKAGE_INFO=$(nuget list "$PACKAGE_ID" -Source https://api.nuget.org/v3/index.json -PreRelease 2>/dev/null | grep -E "^$PACKAGE_ID $PACKAGE_VERSION " || true)
            if [ -n "$LATEST_PACKAGE_INFO" ]; then
                echo -e "\e[32mINFO (fallback):\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION found via nuget list."
                echo "should-release=false" >> $GITHUB_OUTPUT
            else
                echo -e "\e[32mINFO (fallback):\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION not found via nuget list (or nuget list failed)."
                echo "should-release=true" >> $GITHUB_OUTPUT # Assuming if primary check failed and fallback also doesn't find it, it's new
            fi
          fi

      - name: Create GitHub Release for ${{ matrix.project_name }}
        id: create_release_action
        if: steps.check-nuget.outputs.should-release == 'true'
        env:
          PACKAGE_ID: ${{ steps.get-metadata.outputs.package-id }}
          PACKAGE_VERSION: ${{ steps.get-metadata.outputs.package-version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating GitHub release for ${PACKAGE_ID} v${PACKAGE_VERSION}"
          gh release create "${PACKAGE_ID}-v$PACKAGE_VERSION" --generate-notes --title "Release ${PACKAGE_ID} v$PACKAGE_VERSION"
          echo "created_release=true" >> $GITHUB_OUTPUT

      - name: Pack ${{ matrix.project_name }}
        id: pack
        if: steps.check-nuget.outputs.should-release == 'true'
        env:
          PROJECT_NAME: ${{ matrix.project_name }}
          PACKAGE_ID: ${{ steps.get-metadata.outputs.package-id }}
          PACKAGE_VERSION: ${{ steps.get-metadata.outputs.package-version }}
        run: |
          PROJECT_FILE_PATH="src/$PROJECT_NAME/$PROJECT_NAME.csproj"
          echo "Packing $PROJECT_FILE_PATH version $PACKAGE_VERSION"
          dotnet pack "$PROJECT_FILE_PATH" \
            --configuration Release \
            --output ./packages \
            -p:PackageVersion="$PACKAGE_VERSION"
          
          NUPKG_FILENAME="$PACKAGE_ID.$PACKAGE_VERSION.nupkg"
          echo "NuGet package will be: $NUPKG_FILENAME"
          echo "nupkg_path=./packages/$NUPKG_FILENAME" >> "$GITHUB_OUTPUT"
          echo "nupkg_filename=$NUPKG_FILENAME" >> "$GITHUB_OUTPUT"


      - name: Push ${{ matrix.project_name }} to NuGet.org
        if: steps.check-nuget.outputs.should-release == 'true'
        env:
          NUGET_ORG_API_KEY: ${{ secrets.NUGET_ORG_API_KEY }}
          NUPKG_PATH: ${{ steps.pack.outputs.nupkg_path }}
        run: |
          echo "Pushing ${{ steps.pack.outputs.nupkg_filename }} to NuGet.org"
          dotnet nuget push "$NUPKG_PATH" --source https://api.nuget.org/v3/index.json --api-key "$NUGET_ORG_API_KEY"
