# This workflow automatically creates a release and publishes to nuget.org, if the package version does not already
# exist. For now it is just copied from this work in progress (which has more context in comments):
#   https://github.com/ehonda/EHonda.HelloNuget/blob/eb9bd36a907fb7ca57b6a88df6e935a285517ca4/.github/workflows/auto-release.yml
#
# This GitHub Actions workflow, named "Release and publish to nuget.org", is triggered on pushes to the `main` branch.
# It orchestrates a series of jobs for multiple projects within the `src` directory to:
#   1. Run tests using a reusable workflow.
#   2. For each specified project:
#      a. Extract package metadata (version and ID).
#      b. Check if the extracted package version already exists on nuget.org.
#      c. If the package version does not exist, create a new GitHub release for that package.
#      d. Subsequently, pack the project and publish the new version to nuget.org.
#
# It originates from this:
#   https://github.com/ehonda/EHonda.HelloNuget/blob/eb9bd36a907fb7ca57b6a88df6e935a285517ca4/.github/workflows/auto-release.yml
#
name: Release and publish to nuget.org

# ➡️ Currently disabled, we first have to set up the `NUGET_ORG_API_KEY` secret in the repository settings.
# `workflow_dispatch` is just a placeholder, because `on` is required.
on:
  workflow_dispatch:
#   push:
#     branches:
#       - main

jobs:
  # This job, "test", executes the project's tests.
  # It achieves this by calling the reusable workflow defined in `./.github/workflows/dotnet-test.yml`.
  # This step is crucial for ensuring code quality and correctness before any release or publishing actions are taken.
  test:
    uses: ./.github/workflows/dotnet-test.yml

  # This job, "package-pipeline", processes each specified project from the `src` directory.
  # It uses a matrix strategy to handle each project independently.
  # For each project, it extracts metadata, checks NuGet.org for existing versions,
  # and outputs whether a release should proceed.
  package-pipeline:
    name: Build & Check ${{ matrix.project_name }}
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        # Define the list of projects in src/ to be released.
        # Assumes project file is src/<project_name>/<project_name>.csproj
        project_name: [Core, CursorBased, OffsetBased, Sequential]
    outputs:
      package_version: ${{ steps.get-metadata.outputs.package-version }}
      package_id: ${{ steps.get-metadata.outputs.package-id }}
      should_release: ${{ steps.check-nuget.outputs.should-release }}
      project_name: ${{ matrix.project_name }} # Pass along for dependent jobs
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9 # Consider making this configurable if needed

      - name: Get package metadata for ${{ matrix.project_name }}
        id: get-metadata
        run: |
          PROJECT_FILE_PATH="src/${{ matrix.project_name }}/${{ matrix.project_name }}.csproj"
          echo "Attempting to get PackageVersion from $PROJECT_FILE_PATH"
          # Get raw output first
          VERSION_RAW=$(dotnet build "$PROJECT_FILE_PATH" --getProperty:PackageVersion --nologo -v q)
          echo "Attempting to get PackageId from $PROJECT_FILE_PATH"
          ID_RAW=$(dotnet build "$PROJECT_FILE_PATH" --getProperty:PackageId --nologo -v q)

          echo "Raw output for Version for ${{ matrix.project_name }}: [$VERSION_RAW]"
          echo "Raw output for ID for ${{ matrix.project_name }}: [$ID_RAW]"

          # Trim all leading/trailing whitespace using xargs
          VERSION_VAL=$(echo "$VERSION_RAW" | xargs)
          ID_VAL=$(echo "$ID_RAW" | xargs)
          
          echo "Trimmed Version for ${{ matrix.project_name }}: [$VERSION_VAL]"
          echo "Trimmed ID for ${{ matrix.project_name }}: [$ID_VAL]"
          
          if [ -z "$VERSION_VAL" ]; then
            echo "::error::PackageVersion is empty or only whitespace for $PROJECT_FILE_PATH. Raw: [$VERSION_RAW]"
            exit 1
          fi
          if [ -z "$ID_VAL" ]; then
            echo "::error::PackageId is empty or only whitespace for $PROJECT_FILE_PATH. Raw: [$ID_RAW]"
            exit 1
          fi
          
          echo "package-version=$VERSION_VAL" >> "$GITHUB_OUTPUT"
          echo "package-id=$ID_VAL" >> "$GITHUB_OUTPUT"

      - name: Check nuget.org package exists for ${{ matrix.project_name }}
        id: check-nuget
        env:
          PACKAGE_VERSION: ${{ steps.get-metadata.outputs.package-version }}
          PACKAGE_ID: ${{ steps.get-metadata.outputs.package-id }}
        run: |
          PKG_ID_LOWER=$(echo "$PACKAGE_ID" | tr '[:upper:]' '[:lower:]')
          PKG_VERSION_LOWER=$(echo "$PACKAGE_VERSION" | tr '[:upper:]' '[:lower:]')
          # Note: NuGet API v3 registration hives (the URL below) are eventually consistent.
          # A very recently published package might briefly return 404.
          NUGET_URL="https://api.nuget.org/v3/registration5-semver1/$PKG_ID_LOWER/$PKG_VERSION_LOWER.json"
          
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$NUGET_URL")
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo -e "\e[32mINFO:\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION already exists on NuGet.org."
            echo "should-release=false" >> $GITHUB_OUTPUT
          elif [ "$HTTP_STATUS" -eq 404 ]; then
            echo -e "\e[32mINFO:\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION does not exist on NuGet.org."
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            echo -e "\e[31mERROR:\e[0m Failed to check NuGet.org for package $PACKAGE_ID@$PACKAGE_VERSION. HTTP Status: $HTTP_STATUS"
            echo "Attempting fallback check with 'nuget list'..."
            # Fallback to original nuget list logic if curl fails unexpectedly
            # This requires `nuget` CLI to be available; actions/setup-dotnet might not install it by default.
            # Consider adding a step to install nuget CLI if this fallback is critical.
            # For now, assuming it might be available or this part is best-effort on error.
            LATEST_PACKAGE_INFO=$(nuget list "$PACKAGE_ID" -Source https://api.nuget.org/v3/index.json -PreRelease | grep -E "^$PACKAGE_ID $PACKAGE_VERSION ")
            if [ -n "$LATEST_PACKAGE_INFO" ]; then
                echo -e "\e[32mINFO (fallback):\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION found via nuget list."
                echo "should-release=false" >> $GITHUB_OUTPUT
            else
                echo -e "\e[32mINFO (fallback):\e[0m Package $PACKAGE_ID@$PACKAGE_VERSION not found via nuget list."
                echo "should-release=true" >> $GITHUB_OUTPUT # Or false if error implies uncertainty
            fi
          fi

  # This job, "Create release", creates a new GitHub release for each package that needs updating.
  # It runs if the `package-pipeline` job for a specific project determines that
  # the package version does not already exist on nuget.org.
  # It requires `contents: write` permission to create the release.
  # It tags the release with `<package-id>-v<package-version>` (e.g., "MyLib.Core-v1.2.3").
  create-release:
    name: Create GitHub Release for ${{ matrix.project_name }} # Use matrix context for name
    runs-on: ubuntu-latest
    permissions:
      contents: write
    needs: package-pipeline
    strategy:
      matrix: # Mirror the strategy from package-pipeline
        project_name: [Core, CursorBased, OffsetBased, Sequential]
    outputs: # Define outputs for the publish job
      project_name_out: ${{ matrix.project_name }}
      package_id_out: ${{ steps.get_params.outputs.package_id_val }}
      package_version_out: ${{ steps.get_params.outputs.package_version_val }}
      # Output a flag indicating if a release was actually created for this matrix instance
      created_release_flag_out: ${{ steps.create_release_action.outputs.created_release || 'false' }}
    steps:
      - name: Get parameters for ${{ matrix.project_name }}
        id: get_params
        run: |
          PROJECT_NAME_CURRENT_MATRIX="${{ matrix.project_name }}"
          
          # Access outputs from the corresponding package-pipeline matrix instance using toJSON(matrix)
          # The toJSON(matrix) context provides a string like '{"project_name":"Core"}'
          # which should match the keys in the outputs map from the package-pipeline matrix job.
          CURRENT_PACKAGE_ID="${{ needs.package-pipeline.outputs.package_id[toJSON(matrix)] }}"
          CURRENT_PACKAGE_VERSION="${{ needs.package-pipeline.outputs.package_version[toJSON(matrix)] }}"
          CURRENT_SHOULD_RELEASE="${{ needs.package-pipeline.outputs.should_release[toJSON(matrix)] }}"

          echo "package_id_val=$CURRENT_PACKAGE_ID" >> $GITHUB_OUTPUT
          echo "package_version_val=$CURRENT_PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "should_release_val=$CURRENT_SHOULD_RELEASE" >> $GITHUB_OUTPUT
          
          echo "Debug - Project (create-release): ${PROJECT_NAME_CURRENT_MATRIX}"
          echo "Debug - Matrix Context (create-release for keying): ${{ toJSON(matrix) }}"
          echo "Debug - Retrieved Package ID: [$CURRENT_PACKAGE_ID]"
          echo "Debug - Retrieved Package Version: [$CURRENT_PACKAGE_VERSION]"
          echo "Debug - Retrieved Should Release: [$CURRENT_SHOULD_RELEASE]"
          # For more detailed debugging, uncomment the line below to see the structure of one of the output maps:
          # echo "Debug - All package_id outputs from package-pipeline: ${{ toJSON(needs.package-pipeline.outputs.package_id) }}"

      - name: Checkout
        uses: actions/checkout@v4
        if: steps.get_params.outputs.should_release_val == 'true'

      - name: Create release action for ${{ matrix.project_name }}
        id: create_release_action # Give this step an ID to reference its outputs
        if: steps.get_params.outputs.should_release_val == 'true'
        env:
          PACKAGE_ID: ${{ steps.get_params.outputs.package_id_val }}
          PACKAGE_VERSION: ${{ steps.get_params.outputs.package_version_val }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${PACKAGE_ID}-v$PACKAGE_VERSION" --generate-notes --title "Release ${PACKAGE_ID} v$PACKAGE_VERSION"
          echo "created_release=true" >> $GITHUB_OUTPUT # Output for this step

  # This job, "publish", is responsible for publishing each new NuGet package version to nuget.org.
  publish:
    name: Publish ${{ matrix.project_name }} # Use matrix context for name
    runs-on: ubuntu-latest
    needs: create-release # Depends on the create-release matrix job
    strategy:
      matrix: # Mirror the strategy
        project_name: [Core, CursorBased, OffsetBased, Sequential]
    steps:
      - name: Get parameters for ${{ matrix.project_name }}
        id: get_params_for_publish
        run: |
          PROJECT_NAME_CURRENT_MATRIX="${{ matrix.project_name }}"

          # Access outputs from the corresponding create-release matrix instance using toJSON(matrix)
          CURRENT_PACKAGE_ID="${{ needs.create-release.outputs.package_id_out[toJSON(matrix)] }}"
          CURRENT_PACKAGE_VERSION="${{ needs.create-release.outputs.package_version_out[toJSON(matrix)] }}"
          DID_CREATE_RELEASE="${{ needs.create-release.outputs.created_release_flag_out[toJSON(matrix)] }}"

          echo "package_id_val=$CURRENT_PACKAGE_ID" >> $GITHUB_OUTPUT
          echo "package_version_val=$CURRENT_PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "should_publish_val=$DID_CREATE_RELEASE" >> $GITHUB_OUTPUT
          
          echo "Debug - Project (publish): ${PROJECT_NAME_CURRENT_MATRIX}"
          echo "Debug - Matrix Context (publish for keying): ${{ toJSON(matrix) }}"
          echo "Debug - Retrieved Package ID for publish: [$CURRENT_PACKAGE_ID]"
          echo "Debug - Retrieved Package Version for publish: [$CURRENT_PACKAGE_VERSION]"
          echo "Debug - Retrieved Did Create Release for publish: [$DID_CREATE_RELEASE]"
          echo "Debug - Calculated Should Publish: [$DID_CREATE_RELEASE]"
          # For more detailed debugging, uncomment the line below:
          # echo "Debug - All package_id_out outputs from create-release: ${{ toJSON(needs.create-release.outputs.package_id_out) }}"

      - name: Checkout
        uses: actions/checkout@v4
        if: steps.get_params_for_publish.outputs.should_publish_val == 'true'

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9
        if: steps.get_params_for_publish.outputs.should_publish_val == 'true'

      - name: Pack ${{ matrix.project_name }}
        id: pack
        if: steps.get_params_for_publish.outputs.should_publish_val == 'true'
        env:
          PROJECT_NAME: ${{ matrix.project_name }} # Direct from matrix context
          PACKAGE_ID: ${{ steps.get_params_for_publish.outputs.package_id_val }}
          PACKAGE_VERSION: ${{ steps.get_params_for_publish.outputs.package_version_val }}
        run: |
          PROJECT_FILE_PATH="src/$PROJECT_NAME/$PROJECT_NAME.csproj"
          dotnet pack "$PROJECT_FILE_PATH" \
            --configuration Release \
            --output ./packages \
            -p:PackageVersion="$PACKAGE_VERSION"
          
          NUPKG_FILENAME="$PACKAGE_ID.$PACKAGE_VERSION.nupkg"
          echo "nupkg_path=./packages/$NUPKG_FILENAME" >> "$GITHUB_OUTPUT"

      - name: Push ${{ matrix.project_name }} to NuGet.org
        if: steps.get_params_for_publish.outputs.should_publish_val == 'true'
        env:
          NUGET_ORG_API_KEY: ${{ secrets.NUGET_ORG_API_KEY }}
          NUPKG_PATH: ${{ steps.pack.outputs.nupkg_path }}
        run: dotnet nuget push "$NUPKG_PATH" --source https://api.nuget.org/v3/index.json --api-key "$NUGET_ORG_API_KEY"
